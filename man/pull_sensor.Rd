% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pull_sensor.R
\name{pull_sensor}
\alias{pull_sensor}
\title{Pull sensor volume and occupancy}
\usage{
pull_sensor(sensor, pull_date, fill_gaps = TRUE, .quiet = TRUE)
}
\arguments{
\item{sensor}{character, the sensor ID.
See documentation for \code{\link{pull_sensor_ids}} to obtain metro sensor IDs.}

\item{pull_date}{character, the date of data to pull.
Needs to by in "YYYY-MM-DD" format.}

\item{fill_gaps}{boolean, whether to fill gaps in the time series with \code{NA}
values. Default is \code{TRUE}}

\item{.quiet}{boolean, whether to hide messages. Default is TRUE}
}
\value{
data frame containing variables volume, occupancy, sensor, date, time.
}
\description{
Create a tidy data frame, containing volume and occupancy, for a single date and sensor.
Use \code{\link{pull_sensor_ids}} to obtain metro sensor IDs.
}
\details{
\subsection{Output}{\preformatted{A complete year's worth of data for volume or occupancy for one sensor
 usually results in a file that is around ~30-31KB.

Approximate time to pull one sensor's and one extension's
 (v or c for volume or occupancy, respectively) data across
  a year on a Mac is 1.33 minutes.

Also note that if you assign `pull_sensor()`'s output, the result is returned in-memory,
and there must be sufficient space in-memory to do so.
}
}

\subsection{Missing data}{\preformatted{Occupancy *can* be missing while volume data exists and vice versa.
It is unknown how a loop could be monitoring volume and not occupancy.
}
}
}
\examples{
\dontrun{
# Simple example
loop_data <- pull_sensor(5474, "2018-10-14")

# Mapping example
date_range <- seq(as.Date("2019/01/01"), as.Date("2019/01/02"), by = "days")
loop_data <- pmap(list(8564, date_range), pull_sensor)
loops_full <- rbindlist(loop_data)

# Parallel mapping example
## takes longer if only pulling 1-2 days because libraries are copied to each core
library(parallel)
cl <- makeCluster(detectCores() - 1) # Leaving one core unused
params <- list(8564, date_range)

clusterSetRNGStream(cl, 1)
loop_data <- params \%>\%
  lift(clusterMap, cl = cl)(fun = pull_sensor)
stopCluster(cl)

loops_full <- rbindlist(loop_data)
}
}
\seealso{
Other loop sensor functions: 
\code{\link{pull_configuration}()},
\code{\link{pull_sensor_ids}()}
}
\concept{loop sensor functions}
